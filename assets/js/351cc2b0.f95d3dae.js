"use strict";(self.webpackChunkneetoons_blog=self.webpackChunkneetoons_blog||[]).push([[9038],{2289:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>t});const s=JSON.parse('{"id":"El lenguaje Pawn/Inicializadores","title":"Inicializadores","description":"Bueno ahora vamos a avanzar un poco m\xe1s all\xe1 de las cl\xe1sicas definiciones y vamos a comprender un poco m\xe1s sobre este lenguaje de programaci\xf3n.","source":"@site/docs/El lenguaje Pawn/13 - Inicializadores.md","sourceDirName":"El lenguaje Pawn","slug":"/El lenguaje Pawn/Inicializadores","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Inicializadores","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/El lenguaje Pawn/13 - Inicializadores.md","tags":[],"version":"current","sidebarPosition":13,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Control de Flujo","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Control de Flujo"},"next":{"title":"Strings empaquetados","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Strings empaquetados"}}');var r=a(4848),o=a(8453);const i={},l="new`",c={},t=[{value:"<code>new</code>",id:"new-1",level:2},{value:"<code>public</code>",id:"public",level:2},{value:"<code>stock</code>",id:"stock",level:2},{value:"<code>const</code>",id:"const",level:2},{value:"<code>static</code>",id:"static",level:2},{value:"<code>enum</code>",id:"enum",level:2},{value:"operador elipsis <code>...</code>",id:"operador-elipsis-",level:3}];function d(e){const n={br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Bueno ahora vamos a avanzar un poco m\xe1s all\xe1 de las cl\xe1sicas definiciones y vamos a comprender un poco m\xe1s sobre este lenguaje de programaci\xf3n."}),"\n",(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"new",children:"new`"})}),"\n",(0,r.jsx)(n.h2,{id:"new-1",children:(0,r.jsx)(n.code,{children:"new"})}),"\n",(0,r.jsx)(n.h2,{id:"public",children:(0,r.jsx)(n.code,{children:"public"})}),"\n",(0,r.jsx)(n.p,{children:"Global \u201csimple\u201d variables (no arrays) may be declared \u201cpublic\u201d in two ways:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"declare the variable using the keyword public instead of new;"}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"start the variable name with the \u201c@\u201d symbol."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Public variables behave like global variables, with the addition that the host program can also read and write public variables. A (normal) global variable can only be accessed by the functions in your script \u2014the host",(0,r.jsx)(n.br,{}),"\n","program is unaware of them. As such, a host program may require that you declare a variable with a specific name as \u201cpublic\u201d for special purposes \u2014such as the most recent error number, or the general program state."]}),"\n",(0,r.jsx)(n.h2,{id:"stock",children:(0,r.jsx)(n.code,{children:"stock"})}),"\n",(0,r.jsx)(n.p,{children:"A global variable may be declared as \u201cstock\u201d. A stock declaration is one that the parser may remove or ignore if the variable turns out not to be used in the program."}),"\n",(0,r.jsx)(n.p,{children:"Stock variables are useful in combination with stock functions. A public vari- able may be declared as \u201cstock\u201d as well \u2014declaring public variables as \u201cpublic stock\u201d enables you to declare al public variables that a host application pro- vides in an include file, with only those variables that the script actually uses winding up in the P-code file."}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfQu\xe9 es stock?"}),(0,r.jsx)(n.br,{}),"\n","stock define una variable/array o funci\xf3n, pero con la particularidad de que si dicha variable/funci\xf3n no es utilizada, entonces se omitir\xe1 en la compilaci\xf3n y no ocupara lugar."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfC\xf3mo se utiliza?"}),(0,r.jsx)(n.br,{}),"\n","La forma de utilizaci\xf3n es la misma que utilizamos normalmente"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"//Variables/arrays:\nstock\n    variable,\n    array[5];\n\n//Funciones:\nstock MiFuncion();\n"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"?Para qu\xe9 se utiliza?"}),(0,r.jsx)(n.br,{}),"\n","B\xe1sicamente se utiliza para ahorrar memoria y espacio; pero tambi\xe9n se lo utiliza para evitar advertencias sobre definiciones de elementos que luego no se utilizan."]}),"\n",(0,r.jsx)(n.h2,{id:"const",children:(0,r.jsx)(n.code,{children:"const"})}),"\n",(0,r.jsx)(n.p,{children:"It is sometimes convenient to be able to create a variable that is initialized once and that may not be modified. Such a variable behaves much like a symbolic constant, but it still is a variable."}),"\n",(0,r.jsx)(n.p,{children:"To declare a constant variable, insert the keyword const between the keyword that starts the variable declaration \u2014new, static, public or stock\u2014 and the variable name."}),"\n",(0,r.jsx)(n.p,{children:"Examples:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"\nnew const address[4] = { 192, 0, 168, 66 }\n\npublic const status           /* initialized to zero */\n\n"})}),"\n",(0,r.jsx)(n.p,{children:"Three typical situations where one may use a constant variable are:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"To create an \u201carray\u201d constant; symbolic constants cannot be indexed."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"For a public variable that should be set by the host application, and only by the host application. See the preceding section for public variables."}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:"A special case is to mark array arguments to functions as const. Array arguments are always passed by reference, declaring them as const guards against unintentional modification. Refer to page 72 for an example of const function arguments."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfQu\xe9 es const?"}),(0,r.jsx)(n.br,{}),"\n","Se utiliza para definir constantes. Las constantes son variables/arrays cuyo valor no se modificara."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfC\xf3mo se utiliza?"}),(0,r.jsx)(n.br,{}),"\n","La forma de utilizaci\xf3n es la misma que utilizamos normalmente, pero debemos especificar el valor cuando creamos la variable/array."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'//Variables\nconst variable = 15;\nnew const variable = 15;\nstock const variable = 30;\n\n//Arrays\nconst array[5] = "Hola";\nnew const array[5] = "Hola";\nstock const array[] = "Hola";\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Nota:"}),"\xa0Como pueden ver, en la declaraci\xf3n de un array, podemos obviar indicar el tama\xf1o de la ultima dimensi\xf3n."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfPor qu\xe9 se utiliza?"}),(0,r.jsx)(n.br,{}),"\n","Podr\xe1n preguntarse, porque no colocar directamente el valor y utilizar una variable constante. Bueno, la respuesta es que mediante la utilizaci\xf3n de arrays/variables constantes, estos valores",(0,r.jsx)(n.br,{}),"\n",'si se repiten solo se almacenan 1 vez en memoria; en cambio si utiliz\xe1ramos directamente el valor "hola", el mismo estar\xe1 en la memoria tantas veces como lo utilicemos. Es decir si usamos "hola"',(0,r.jsx)(n.br,{}),"\n","5 veces en el script, en la memoria estar\xe1 5 veces; ademas es mas r\xe1pido acceder a una variable constante que a un texto."]}),"\n",(0,r.jsx)(n.h2,{id:"static",children:(0,r.jsx)(n.code,{children:"static"})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"\xbfQu\xe9 es static?"}),(0,r.jsx)(n.br,{}),"\n","Declara una variable/array/funci\xf3n pero con caracter\xedsticas particulares; la variable/array/funci\xf3n declarada puede utilizarse \xfanicamente en el entorno y ademas en el caso de la variable/array, conserva el valor."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'main()\n{\n    MyFunction();\n    print("!");\n    MyFunction();\n    return 1;\n}\n\nMyFunction()\n{\n    static\n        j;\n\n    for(new i; i<3; i++)\n    {\n        printf("%i", j);\n        j++;\n    }\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Este c\xf3digo imprimir\xe1 en la consola:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"0\n1\n2\n!\n3\n4\n5\n"})}),"\n",(0,r.jsx)(n.p,{children:"Mientras que si la variable j no fuera est\xe1tica, la salida seria:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"0\n1\n2\n!\n0\n1\n2\n"})}),"\n",(0,r.jsx)(n.p,{children:"En el caso de las funciones est\xe1ticas o las variables/arrays globales est\xe1ticas, estas solo pueden ser utilizadas en el archivo en el cual fueron declaradas."}),"\n",(0,r.jsx)(n.h2,{id:"enum",children:(0,r.jsx)(n.code,{children:"enum"})}),"\n",(0,r.jsx)(n.p,{children:"\xbfQu\xe9 es un enum?\nUn enum define una lista de elementos a los cuales se les asigna un numero."}),"\n",(0,r.jsx)(n.p,{children:"\xbfC\xf3mo se utiliza?\nLa forma de utilizaci\xf3n es la siguiente:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum nombre\n{\n    elemento_1,\n    elemento_2,\n    elemento_3,\n    ...\n    elemento_n\n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Nota: El ultimo elemento no lleva una , al final."}),"\n",(0,r.jsx)(n.p,{children:"Usos comunes\nTal vez el uso mas com\xfan que le dan a los enums es para almacenar datos de jugadores u otros."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum PlayerData\n{\n    bool:Registrado,\n    bool:Logueado,\n    Dinero,\n    Float:Vida,\n    Nombre[MAX_PLAYER_NAME]\n};\n\nnew PlayerInfo[MAX_PLAYERS][PlayerData];\n\npublic OnPlayerConnect(playerid)\n{\n    PlayerInfo[playerid][Registrado] = false;\n\n    return 1;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Algo m\xe1s...\nHasta aqu\xed todo bien, pero quedarse solo con ese uso de enums es algo pobre. Los enums realmente son como una tabla, cada palabra del enum en realidad tiene un valor constante."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"const e_VAL1 = 0;\nconst e_VAL2 = 1;\nconst e_VAL3 = 2;\n\nnew Array[3];\n\nmain()\n{\n    Array[e_VAL1] = 10;\n    Array[e_VAL2] = 15;\n    Array[e_VAL3] = 120;\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"El c\xf3digo anterior utilizando enums seria el siguiente:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum e_VAL\n{\n    e_VAL1,\n    e_VAL2,\n    e_VAL3\n};\n\nnew Array[3];\n\nmain()\n{\n    Array[e_VAL1] = 10;\n    Array[e_VAL2] = 15;\n    Array[e_VAL3] = 120;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Los dos c\xf3digos son an\xe1logos y compilaran perfectamente. De esta forma demostramos que los enums son valores constantes, estos valores son dados por el compilador",(0,r.jsx)(n.br,{}),"\n","autom\xe1ticamente y comienzan en el 0. Ahora bien, podemos tambi\xe9n ser nosotros quienes coloquemos estos valores."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum e_TEST  \n{  \n\xa0 \xa0 e_UNO = 5,  \n\xa0 \xa0 e_DOS,  \n\xa0 \xa0 e_TRES,  \n\xa0 \xa0 e_CUATRO  \n};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["En el ejemplo anterior, la cuenta comenzara en el numero 5, de esta forma e_DOS es el 6, e_TRES el 4 y as\xed sucesivamente. Pero tambi\xe9n podemos asignar nosotros los valores que queramos",(0,r.jsx)(n.br,{}),"\n","y no \xfanicamente el inicial."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'enum e_TEST  \n{  \n\xa0 \xa0 e_UNO,//0 pues por defecto la cuenta comienza en 0  \n\xa0 \xa0 e_DOS,//1 pues el valor se auto-incrementa en 1  \n\xa0 \xa0 e_TRES = 15,//15 pues asignamos el valor 15  \n\xa0 \xa0 e_CUATRO,//16 pues el valor se auto-incrementa en 1  \n\xa0 \xa0 e_CINCO = 60,//60 pues asignamos el valor 60  \n\xa0 \xa0 e_SEIS[5],//Ahora ac\xe1 hay una diferencia, esto es un bloque de 5 constantes, entonces e_SEIS tiene los valores del 61 hasta el 65  \n\xa0 \xa0 e_SIETE//Obtendr\xe1 el valor siguiente, es decir 66  \n};  \n  \nmain()  \n{  \n\xa0 \xa0 printf("Size: %d", _:e_TEST);//Printeara en la consola "Size: 67" pues el tama\xf1o de nuestro enum es 67  \n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:['Ahora bien, tal vez est\xe9n pensando que deber\xeda haber printeado "Size: 66", pero esto es incorrecto ya que no hablamos del valor m\xe1ximo, si no de la cantidad de slots que tiene, y estos',(0,r.jsx)(n.br,{}),"\n","son 0-66, entonces hay 67 slots."]}),"\n",(0,r.jsx)(n.p,{children:"Veamos otro ejemplo:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'enum e_TEST  \n{  \n\xa0 \xa0 e_UNO,  \n\xa0 \xa0 e_DOS = 15,  \n\xa0 \xa0 e_TRES[5],  \n\xa0 \xa0 e_CUATRO  \n};  \n  \nnew  \n\xa0 \xa0 Test[e_TEST];  \n  \nmain()  \n{  \n\xa0 \xa0 Test[e_UNO] = 15;  \n\xa0 \xa0 Test[e_DOS] = 150;  \n\xa0 \xa0 Test[e_TRES] = "Hola";  \n\xa0 \xa0 Test[e_CUATRO] = 5;  \n\xa0 \xa0 Test[e_TEST:21] = 99;  \n  \n\xa0 \xa0 printf("%d %d %s %d", Test[e_UNO], Test[e_DOS], Test[e_TRES], Test[e_CUATRO]);//Printeara en consola "15 150 Hola 99"  \n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Si esperaban que el c\xf3digo anterior printeara en el ultimo n\xfamero el 5 se equivocaron, pues la ultima asignaci\xf3n sobre-escribe dicho valor."}),"\n",(0,r.jsx)(n.p,{children:"Ahora bien, porque tuve que colocar e_TEST:21 y no simplemente 21? Esto se debe a que los enums tambien son tags."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:'enum E_TEST  \n{  \n\xa0 \xa0 E_UNO,  \n\xa0 \xa0 E_DOS,  \n\xa0 \xa0 E_TRES  \n};  \n  \nnew  \n\xa0 \xa0 E_TEST:Var,  \n\xa0 \xa0 Var2;  \n  \nmain()  \n{  \n\xa0 \xa0 Var = E_TRES;  \n\xa0 \xa0 Var2 = E_TRES;//Nos dar\xe1 una advertencia ya que Var2 es de tipo int y no E_TEST  \n  \n\xa0 \xa0 printf("Var: %d %d", _:Var, Var2);  \n  \n\xa0 \xa0 return 1;  \n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["**Nota:**El tag\xa0",(0,r.jsx)(n.strong,{children:"_:"}),"\xa0se utiliza para remover cualquier tag de la variable/array/etc temporalmente y cambiar el mismo a int."]}),"\n",(0,r.jsx)(n.p,{children:"Los enums tambi\xe9n pueden ser an\xf3nimos, es decir no necesariamente tienen que tener un nombre."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum  \n{  \n\xa0 \xa0 E_UNO,  \n\xa0 \xa0 E_DOS,  \n\xa0 \xa0 E_TRES  \n};\n"})}),"\n",(0,r.jsx)(n.p,{children:"Una particularidad es que existen enums de tag fuerte y d\xe9bil."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"enum E_TEST_1 //Tag fuerte pues comienza con E may\xfascula  \n{  \n\xa0 \xa0 E_UNO,  \n\xa0 \xa0 E_DOS,  \n\xa0 \xa0 E_TRES  \n};  \n  \nenum e_TEST_2 //Tag d\xe9bil pues comienza con e min\xfascula  \n{  \n\xa0 \xa0 e_CUATRO,  \n\xa0 \xa0 e_CINCO,  \n\xa0 \xa0 e_SEIS  \n};  \n  \nmain()  \n{  \n\xa0 \xa0 new  \n\xa0 \xa0 \xa0 \xa0 Var;  \n  \n\xa0 \xa0 Var = E_TEST_1:E_UNO;//Dar\xe1 una advertencia  \n\xa0 \xa0 Var = e_TEST_2:e_CUATRO;//No da advertencia  \n  \n\xa0 \xa0 #pragma unused Var  \n}\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"operador-elipsis-",children:["operador elipsis ",(0,r.jsx)(n.code,{children:"..."})]}),"\n",(0,r.jsx)(n.p,{children:"Se lo conoce como el operador elipsis y uno de los usos que tiene es la inicializaci\xf3n de arrays, este operador utiliza los valores anteriores para asignar los valores sucesivos al array hasta completarlo."}),"\n",(0,r.jsx)(n.p,{children:"Veamos algunos ejemplos an\xe1logos para comprender mejor su funcionamiento:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"new Array[15] = {5, ...};  \nnew Array[15] = {5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"new Array[10] = {0, 1, ...};  \nnew Array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"new Array[6] = {1, 5, ...};  \nnew Array[6] = {1, 5, 10, 15, 20, 25};\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"new Array[10] = {1, 5, 8, ...};  \nnew Array[10] = {1, 5, 8, 11, 14, 17, 20, 23, 26, 29};\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Como podemos observar, es una forma muy r\xe1pida de inicializar arrays sin tener que completar todos los valores. Si con los ejemplos no lo vieron, lo explicare:",(0,r.jsx)(n.br,{}),"\n","El operador elipsis lo que hace es en caso de solo haber un n\xfamero, entonces completa con el mismo hasta el final o bien si hay mas de 1 numero restar los \xfaltimos 2 entre si y a partir del ultimo obtener el siguiente sumando dicha diferencia."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-cpp",children:"new Array[5] = {a, b, ...};\nnew Array[5] = {a, b, b+1*(b-a), b+2*(b-a), b+3*(b-a)};\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>i,x:()=>l});var s=a(6540);const r={},o=s.createContext(r);function i(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);