"use strict";(self.webpackChunkneetoons_blog=self.webpackChunkneetoons_blog||[]).push([[1492],{3919:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>i,contentTitle:()=>t,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"El lenguaje Pawn/Strings","title":"Strings","description":"Ahora que m\xe1s o menos tenemos idea de c\xf3mo se declara una variable y un array, un caso algo m\xe1s particular de los arrays, los strings.","source":"@site/docs/El lenguaje Pawn/4 - Strings.md","sourceDirName":"El lenguaje Pawn","slug":"/El lenguaje Pawn/Strings","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Strings","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/El lenguaje Pawn/4 - Strings.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Arrays","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Arrays"},"next":{"title":"Array Multi-dimensionales","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Array Multi-dimensionales"}}');var s=n(4848),o=n(8453);const l={},t=void 0,i={},c=[];function d(e){const a={br:"br",code:"code",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.p,{children:"Ahora que m\xe1s o menos tenemos idea de c\xf3mo se declara una variable y un array, un caso algo m\xe1s particular de los arrays, los strings."}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"Un 'tipo' de array particular, los strings"})}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"\xbfQu\xe9 es un string?"}),(0,s.jsx)(a.br,{}),"\n","Un string es una cadena de caracteres. Ahora bien si los caracteres no son n\xfameros (y en los arrays se almacenan n\xfameros \xfanicamente) \xbfC\xf3mo podemos almacenar estos caracteres?",(0,s.jsx)(a.br,{}),"\n","Hace mucho tiempo se decidi\xf3 que se crear\xeda una tabla de c\xf3digos, donde a cada car\xe1cter se le asignar\xeda un numero que lo representaba, a esta tabla se la llamo tabla ASCII."]}),"\n",(0,s.jsxs)(a.p,{children:[(0,s.jsx)(a.strong,{children:"\xbfC\xf3mo guardo un string?"}),(0,s.jsx)(a.br,{}),"\n","Para almacenar un string solo basta convertir la cadena y guardarla en el array que queremos."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:'//Almacenaremos el string "hola" en un array llamado MiArray  \nnew MiArray[4] = {72, 111, 108, 97};//En la tabla ascii: H=92, 0=111, l=108, a=97 \xa0(Notar que en esta tabla existen may\xfasculas y min\xfasculas)\n'})}),"\n",(0,s.jsxs)(a.p,{children:["Ahora bien, logramos almacenar un string en el array como quer\xedamos, pero tenemos un nuevo problema, dado que los arrays se guardan en la memoria seguidos, como sabr\xeda el compilador como dejar de leer?",(0,s.jsx)(a.br,{}),"\n","Es decir, supongamos el siguiente ejemplo:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:'new Array_1[5], Array_2[4], Array_3[10];\nArray_1 = {10, 15, 25, 40, 65};\nArray_2 = {72, 111, 108, 97};//Este es nuestro string que contiene la palabra "Hola"\nArray_3 = {15, 26, 14, 51, 85, 64, 35, 12, 45, 36};\n\n//Para ejemplificar simplificaremos todo y pensaremos que esto en memoria, se almacena algo asi:\n10 15 25 40 65 72 111 108 97 15 26 14 51 85 64 35 12 45 36\n               |           |\n'})}),"\n",(0,s.jsxs)(a.p,{children:["Nuestra cadena (Array_2) esta indicada con '|', el problema es que esta no indica su fin. Por este motivo, se creo una convenci\xf3n la cual indica que todos los strings deben terminar",(0,s.jsx)(a.br,{}),"\n","en el car\xe1cter nulo. el cual es representado por el 0. Por este motivo, debemos agregar un slot mas cuando creamos un array, para almacenar all\xed el 0 indicando que termino."]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:'//Almacenaremos el string "hola" en un array llamado MiArray\nnew MiArray[5] = {72, 111, 108, 97, 0};//Agregamos el 0 al final indicando que all\xed termina el texto\n'})}),"\n",(0,s.jsx)(a.p,{children:(0,s.jsx)(a.strong,{children:"Salvedades"})}),"\n",(0,s.jsx)(a.p,{children:"Comparaci\xf3n"}),"\n",(0,s.jsxs)(a.p,{children:["Si bien aun no hablamos de sentencias, estructuras l\xf3gicas y dem\xe1s, es bastante simple de entender y algo b\xe1sico, por lo que cabe destacar esto aqu\xed.",(0,s.jsx)(a.br,{}),"\n","Muchos, seguramente se vieron tentados e intentaron comparar strings de la siguiente forma:"]}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:'new array[5] = "Hola";\nif(array == "Hola")\n'})}),"\n",(0,s.jsx)(a.p,{children:"El problema con este m\xe9todo de comparaci\xf3n, es que esta mal. El operador == compara valores num\xe9ricos \xfanicamente, y los strings, son una cadena de valores.\nPara comparar un string deber\xedamos ir valor por valor, pero esto es algo tedioso, por este motivo hay funciones que nos permiten realizar esto (la funci\xf3n nativa es strcmp, pero\nla idea de este tutorial es evitar meterse en detalles sobre funciones nativas y hablar de una forma mas detallada sobre el lenguaje en si)."}),"\n",(0,s.jsx)(a.p,{children:"Asignaci\xf3n"}),"\n",(0,s.jsx)(a.p,{children:"Los siguientes ejemplos son todos an\xe1logos, es decir son iguales"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{className:"language-cpp",children:"new MiArray[5] = {72, 111, 108, 97, 0};\nnew MiArray[5] = {'H', 'o', 'l', 'a', '\\0'};//Al encerrar una letra entre comillas simples, el compilador luego reemplazara a la misma por su valor ascii\nnew MiArray[5] = \"Hola\";\n"})})]})}function u(e={}){const{wrapper:a}={...(0,o.R)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>l,x:()=>t});var r=n(6540);const s={},o=r.createContext(s);function l(e){const a=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function t(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),r.createElement(o.Provider,{value:a},e.children)}}}]);