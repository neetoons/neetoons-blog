"use strict";(self.webpackChunkneetoons_blog=self.webpackChunkneetoons_blog||[]).push([[4105],{8139:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>l,metadata:()=>r,toc:()=>t});const r=JSON.parse('{"id":"El lenguaje Pawn/Funciones","title":"Funciones","description":"Funciones Simples","source":"@site/docs/El lenguaje Pawn/6 - Funciones.md","sourceDirName":"El lenguaje Pawn","slug":"/El lenguaje Pawn/Funciones","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Funciones","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/El lenguaje Pawn/6 - Funciones.md","tags":[],"version":"current","sidebarPosition":6,"frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Array Multi-dimensionales","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Array Multi-dimensionales"},"next":{"title":"Callbacks","permalink":"/neetoons-blog/docs/El lenguaje Pawn/Callbacks"}}');var o=a(4848),s=a(8453);const l={},i=void 0,c={},t=[];function d(e){const n={br:"br",code:"code",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Funciones Simples"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"\xbfQu\xe9 es una funci\xf3n?"}),(0,o.jsx)(n.br,{}),"\n","Podemos definir a una funci\xf3n como un conjunto de sentencias que son ejecutadas cuando invocamos la funci\xf3n."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"\xbfC\xf3mo crear una funci\xf3n?"}),(0,o.jsx)(n.br,{}),"\n","Una funci\xf3n esta compuesta por 2 partes, la cabecera (header) y el cuerpo (body); el header contiene el inicializador, el tag, el nombre y los par\xe1metros de la misma. El cuerpo por otro",(0,o.jsx)(n.br,{}),"\n","lado, contiene todo el c\xf3digo que se ejecuta."]}),"\n",(0,o.jsxs)(n.p,{children:["Inicializador Tag",":Nombre","(parametros)"]}),"\n","\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{}),(0,o.jsx)(n.th,{})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Inicializador"}),(0,o.jsx)(n.td,{children:"Indica que es una funci\xf3n, puede ser static, stock, public o ninguno (mas adelante veremos que son estos inicializadores"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Tag"}),(0,o.jsx)(n.td,{children:"Tipo de funci\xf3n, al igual que las variables si no se indica ninguno, por defecto es entero. Esto indica el valor que retornara la funci\xf3n (si es que retorna algun valor)."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Nombre"}),(0,o.jsx)(n.td,{children:"Nombre de la funci\xf3n, utilizado luego para invocarla."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Parametros"}),(0,o.jsx)(n.td,{children:"Indica el nombre que se le dara a las variables que reciban los argumentos enviados."})]})]})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Funciones sin par\xe1metros"}),(0,o.jsx)(n.br,{}),"\n","Son funciones a las cuales no se le pasan argumentos, es decir que realizan \xfanicamente una acci\xf3n y siempre la misma."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"stock KickAll()\n{\n    for(new i, j=GetMaxPlayers(); i<j; i++)\n        if(IsPlayerConnected(i))\n            Kick(i);\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Esa es una funci\xf3n muy simple que solo kickea a todos los jugadores conectados."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Funciones con par\xe1metros"}),(0,o.jsx)(n.br,{}),"\n","Son funciones las cuales reciben argumentos los cuales pueden variar y seg\xfan los mismos puede que la funci\xf3n ejecute diferentes sentencias."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"stock GivePlayerMoney(playerid, money)  \n{  \n\xa0 \xa0 if(IsPlayerConnected(playerid))  \n\xa0 \xa0 {  \n\xa0 \xa0 \xa0 \xa0 if(money >= 0)  \n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 GivePlayerMoney(playerid, money);  \n\xa0 \xa0 \xa0 \xa0 else  \n\xa0 \xa0 \xa0 \xa0 \xa0 \xa0 GivePlayerMoney(playerid, -money);  \n\xa0 \xa0 }  \n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"La funci\xf3n anterior siempre otorgara una cantidad positiva de dinero al jugador."}),"\n",(0,o.jsx)(n.p,{children:"Funciones con retorno de valores\nLas funciones pueden retornar valores, pero el tipo de valor retornado debe ser siempre el mismo y debe coincidir con el tipo de la funci\xf3n."}),"\n",(0,o.jsx)(n.p,{children:"Existen dos formas de retornar valores (aun que por claridad sugiero utilizar la primera):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"stock GetConnectedPlayers()\n{\n    new\n    count;\n\n    for(new i; i<GetMaxPlayers(); i++)\n        if(IsPlayerConnected(i))\n            count++;\n\n    return count;\n}\n"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"stock GetConnectedPlayers()\n{\n    new\n    count;\n\n    for(new i; i<GetMaxPlayers(); i++)\n        if(IsPlayerConnected(i))\n            count++;\n\n    GetConnectedPlayers = count;\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"Ahora voy a mostrar una forma err\xf3nea de retornar valores."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'stock Suma(valor1, valor2)\n{\n    new str[128];\n    if(!IsNumeric(valor1) || !IsNumeric(valor2)){\n        str = "ERROR: Los valores deben ser num\xe9ricos";\n        return str;\n    }\n    return valor1+valor2;\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"La funci\xf3n Suma, va a generar un error a la hora de compilar, dado que el primer valor que retorna es un string o array, mientras que el segundo es un numero entero."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.strong,{children:"Funciones Complejas"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pasar par\xe1metros como opcionales"}),(0,o.jsx)(n.br,{}),"\n","Esto es realmente muy simple en realidad, solo debemos agregar '=valor_default' a la variable q queramos que sea opcional y listo."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'stock SetPlayerTimeEx(playerid, hora, minutos=0)  \n{  \n\xa0 \xa0 SetPlayerTime(playerid, hora, minutos);  \n\xa0 \xa0 printf("Un admin seteo la hora de %i a %i:%i", playerid, hora, minutos);  \n}  \n  \n//Como tiene par\xe1metros opcionales podemos:  \nSetPlayerTimeEx(playerid, 12);\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"stock SetPlayerPosEx(playerid, Float:x, Float:y, Float:z, Float:a=0.0, Float:health=-1.0)  \n{  \n\xa0 \xa0 SetPlayerPos(playerid, x, y, z);  \n\xa0 \xa0 SetPlayerFacingAngle(playerid, a);  \n\xa0 \xa0 if(health != -1.0)  \n\xa0 \xa0 \xa0 \xa0 SetPlayerHealth(playerid, health);  \n  \n\xa0 \xa0 return 1;  \n}  \n  \n//Si quisi\xe9ramos utilizar la funci\xf3n con el par\xe1metro health pero no el angulo accedemos as\xed:  \nSetPlayerPosEx(playerid, 0.0, 0.0, 0.0, .health=100.0);\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Pasar par\xe1metros por valor y por referencia"}),(0,o.jsx)(n.br,{}),"\n","Par\xe1metro por valor, a la funci\xf3n le llega una copia del valor. Podemos modificar el mismo pero el original no cambiara."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'main()  \n{  \n\xa0 \xa0 new  \n\xa0 \xa0 \xa0 \xa0 val_0 = 1,  \n\xa0 \xa0 \xa0 \xa0 val_1 = 3,  \n\xa0 \xa0 \xa0 \xa0 val_2 = Func(val_0, val_1);  \n  \n\xa0 \xa0 //Si bien Func modifica los valores que le dimos, val_0 y val_1 seguir\xe1n valiendo 1 y 3 respectivamente  \n\xa0 \xa0 printf("%i %i %i", val_0, val_1, val_2);  \n  \n}  \n  \nstock Func(valor_0, valor_1)  \n{  \n\xa0 \xa0 valor_0 -= Valor_1 * 5;//modificamos valor_0  \n\xa0 \xa0 return valor_1 += Valor_0 + Valor_2;  \n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:['Ahora bien, existe una forma de editar los valores que se le asignan a una funci\xf3n. Esto es lo que se conoce como "por referencia". Para hacer esto, solo es necesario agregar',(0,o.jsx)(n.br,{}),"\n","el car\xe1cter '&' delante de la variable que queremos pasar como referencia, de lo contrario (si no lo ponemos), esta variable ser\xe1 pasada por valor."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'main()  \n{  \n\xa0 \xa0 new  \n\xa0 \xa0 \xa0 \xa0 val_0 = 1,  \n\xa0 \xa0 \xa0 \xa0 val_1 = 3,  \n\xa0 \xa0 \xa0 \xa0 val_2 = Func(val_0, val_1);  \n  \n\xa0 \xa0 printf("%i %i %i", val_0, val_1, val_2);  \n  \n}  \n  \nstock Func(&valor_0, &valor_1)  \n{  \n\xa0 \xa0 valor_0 -= Valor_1 * 5;  \n\xa0 \xa0 return valor_1 += Valor_0 + Valor_2;  \n}\n'})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Importante:"}),"\xa0por defecto, los arrays no pueden ser pasados por valor, \xbfQu\xe9 quiere decir esto? que si en una funci\xf3n especificamos uno de los par\xe1metros como array, ser\xe1 pasado autom\xe1ticamente por referencia y no por valor. Para pasar un array por valor se debe agregar 'const' delante del mismo."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Par\xe1metros variables"}),(0,o.jsx)(n.br,{}),"\n","Para crear una funci\xf3n con par\xe1metros indefinidos, debemos hacerlo utilizando la elipsis y podemos ayudarnos con otras funciones nativas para saber la cantidad de argumentos y obtener un argumento seg\xfan el index del mismo."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:'main()  \n{  \n\xa0 \xa0 printf("%i", SumaTodo(5, 6, 1, 100, 8));  \n\xa0 \xa0 printf("%i", SumaTodo(1, 9, 6, 169, 17, 65, 243, 213));  \n}  \n  \nstock SumaTodo(...)  \n{  \n\xa0 \xa0 new res;  \n\xa0 \xa0 for(new i; i<numargs(); i++)res += getarg(i);  \n\xa0 \xa0 return res;  \n}\n'})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-cpp",children:"//Declaraci\xf3n:  \nSetPlayerRandomColor(playerid, ...)  \n{  \n\xa0 \xa0 new  \n\xa0 \xa0 \xa0 \xa0 rnd,  \n\xa0 \xa0 \xa0 \xa0 count;  \n  \n\xa0 \xa0 count = numargs() - 1;//numeramos los argumentos.  \n\xa0 \xa0 rnd = random(count);  \n  \n\xa0 \xa0 if(!count)  \n\xa0 \xa0 \xa0 \xa0 return SetPlayerColor(playerid, GetPlayerColor(playerid));  \n  \n\xa0 \xa0 return SetPlayerColor(playerid, getarg((!rnd) ? (1) : (rnd)));  \n}  \n  \n//Uso:  \nSetPlayerColor(playerid, 0xFF0000FF, 0xFFFF00FF, 0x0000FF66, 0x66FFA8FF);\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>l,x:()=>i});var r=a(6540);const o={},s=r.createContext(o);function l(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);